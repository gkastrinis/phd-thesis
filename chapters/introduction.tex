\label{chapter:intro}

\epigraph{Sometimes a scream is better than a thesis.}{\textit{Manfred Eigen}}

Static program analysis is the cornerstone of several modern programming facilities and tools for program development and aided program understanding. Nowadays, it is an umbrella term for many different methodologies (...) all with the ultimate goal of inferring a program's properties, without actually running it. It is routinely employed in many different contexts: compilers, bug detectors, verifiers, security analyzers, IDEs, and a myriad other tools.

Pointer analysis (also known as \emph{Points-To analysis}) is a fundamental subcategory of static program analysis that consists of computing some \emph{abstract memory model} for a given program. The essence of such an analysis is to compute a set of possible objects that a program variable or expression may point to during program execution. A straightforward endeavor at first, it quickly gets too complicated in practice due to all of the intricate details one has to take into account and the multitude of different features that mutually depend on each other.

At the same time, programming languages are ever evolving, ever becoming more high-level and more complex. Many abstraction levels are added throughout the years with the aim of making the very task of programming easier for developers allowing them to express more with less effort (e.g., in terms of lines of code). Frequently, new features come with complicated semantics regarding their possible implementations and usually they interact in intricate ways with pre-existing ones.

Additionally, modern software has evolved as well. Complex design patterns have become the norm for experienced developers, immense libraries and frameworks are accepted as a prerequisite for any sophisticated software, and over-involved build tools often make even the task of understanding all of the program's dependencies a challenge.

It comes as no surprise that any kind of static analysis has struggled to keep up with this ever-increasing complexity both in programming languages and software. Even the seemingly simple task of computing a program's call-graph (i.e., which program functions can call which others), if one tries to have an approach as general as possible, requires sophisticated analysis in order to achieve the desirable precision. Thus, the main emphasis of pointer analysis algorithms is on combining fairly precise modeling of pointer behavior and memory abstractions with scalability.

\paragraph*{Thesis.}
\begin{displayquote}
It is possible to implement \emph{highly sophisticated} and \emph{precise} static pointer analysis algorithms without forgoing \emph{scalability}. Furthermore, precision and the accompanied \emph{confidence in results} is a spectrum and can be tweaked differently for different parts of the program.
\end{displayquote}

We provide a couple of different static pointer analysis algorithms with different approaches on attaining the desired scalability while at the same time keeping high levels of precision. In addition, we explore two different directions on achieving highly confident results for portions of the program even if precision is difficult to be maintained for the whole program text.

\section{Pointer Analysis}

Although a challenging task, if implemented correctly and not naively it can bear many significant benefits to client analyses that consume its results to reason about specialized behaviors such as security vulnerabilities or potential optimization opportunities. Throughout the years, pointer analysis has evolved and has been the focus of intense research. It is widely accepted to be among the most standardized and well-understood inter-procedural analyses.

\subsection{Context-Sensitivity}


\section{Impact}

In this section, we will briefly explain the main contributions of this dissertation, from both a scientific and a practical perspective.

\subsection{Scientific Contributions}


\subsection{Practical Contributions}


\section{Outline}

The rest of this dissertation is organized as follows:
\begin{itemize}%[--]
\item Chapter~\ref{chapter:hybrid} bla blaasda

    This chapter presents research previously published in...
  %\emph{\citetitle{foo}} \cite{foo}.

\item Chapter~\ref{chapter:introspective} bla bla

    This chapter presents research previously published in...

\item Chapter~\ref{chapter:must} bla bla

    This chapter presents research previously published in...

\item Chapter~\ref{chapter:defensive} bla bla

    This chapter presents research previously published in...
    
\item Chapter~\ref{chapter:panda} bla bla

\item Chapter~\ref{chapter:related} first discusses related work that
  is specific to the previous chapters, and then expands to various
  other interesting subjects in the broader realm of static analysis.
%   Some parts of this chapter are based on the aforementioned papers
%   \cite{structsens,reflection,jphantom}, and some on the survey
%   \emph{\citetitle{survey}} \cite{survey}.

\item Chapter~\ref{chapter:conclusions} concludes this dissertation by assessing our initial thesis and discussing future work.
\end{itemize}